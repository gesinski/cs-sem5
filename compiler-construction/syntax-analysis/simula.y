%{
#include <stdio.h> /* printf() */
#include <string.h> /* strcpy() */
#include "common.h" /* MAX_STR_LEN */
int yylex(void);
void yyerror(const char *txt);
 
void found( const char *nonterminal, const char *value );
%}

%union 
{
        char s[ MAX_STR_LEN + 1 ]; /* text field for idents etc. */
        int i; /* integer field */
        double d; /* floating point field */
}

%debug

%token<i> KW_ACTIVATE KW_AFTER KW_AND KW_ARRAY KW_AT KW_BEFORE KW_BEGIN
%token<i> KW_BOOLEAN KW_CHARACTER KW_CLASS KW_COMMENT KW_DELAY KW_DO
%token<i> KW_ELSE KW_END KW_EQ KW_EQV KW_EXTERNAL KW_FALSE KW_FOR KW_GE
%token<i> KW_GO KW_GOTO KW_GT KW_HIDDEN KW_IF KW_IMP KW_IN KW_INNER
%token<i> KW_INSPECT KW_INTEGER KW_IS KW_LABEL KW_LONG KW_LT KW_NAME KW_NE
%token<i> KW_NEW KW_NONE KW_NOT KW_NOTEXT KW_OR KW_OTHERWISE KW_PRIOR
%token<i> KW_PROCEDURE KW_PROTECTED KW_QUA KW_REACTIVATE KW_REAL KW_REF
%token<i> KW_SHORT KW_STEP KW_SWITCH KW_TEXT KW_THEN KW_THIS KW_TO KW_TRUE
%token<i> KW_UNTIL KW_VALUE KW_VIRTUAL KW_WHEN KW_WHILE
%token<i> INTEGER_CONST
%token<s> TEXT_CONST CHARACTER_CONST IDENT
%token<i> ASSIGN REF_ASSIGN INT_DIV EXPO REF_EQ REF_NE POWER
%token<d> REAL_CONST

 /* Precedence of operators */
%left '+' '-'
%left '*' '/' INT_DIV
%left EXPO
%nonassoc '<' KW_LE '=' KW_GE '>' KW_NE KW_IS KW_IN
%right KW_NOT

%type<s> MAIN_PART PROCEDURE_HEADING IDENTIFIER_1 PROCEDURE_STATEMENT
%type<s> REMOTE_PREFIX PREFIX

%%

 /* Structure of a Simula program */

 /* program can be empty (semantic error),
    it may contain a syntax error,
    or it may consist of statements (STATEMENTS) */
GRAMMAR: %empty { yyerror("File is ampty"); YYERROR; }
	| error
        /* !!! Start here !!! */
   | STATEMENTS
   {
      found("End of program", "");
   }
;

/* BLOCK */
BLOCK:
      BLOCK_HEAD COMPOUND_TAIL
;

/* BLOCK_HEAD */
BLOCK_HEAD:
      KW_BEGIN DECLARATIONS
;

DECLARATIONS:
      %empty 
    | DECLARATION ';' DECLARATIONS 
;

/* DECLARATION */
DECLARATION:
      PROCEDURE_DECLARATION  
    | CLASS_DECLARATION 
    | SIMPLE_VARIABLE_DECLARATION 
    | ARRAY_DECLARATION  
;

/* CLASS_DECLARATION */
CLASS_DECLARATION:
      OPT_IDENT MAIN_PART
      {
         found("CLASS_DECLARATION", $2);
      }
;

/* OPT_IDENT */
OPT_IDENT:
      %empty
    | IDENT
;

/* MAIN_PART */
MAIN_PART:
      KW_CLASS IDENT FVS_PART ';' OPT_VIRTUAL_PART CLASS_BODY
      {
         found("MAIN_PART", $2);
         strcpy($$, $2);
      }
;

/* FVS_PART */
FVS_PART:
      FORMAL_PARAMETER_PART ';' OPT_VALUE_PART
      {
         found("FVS_PART", "");
      }
    | %empty
      {
         found("empty FVS_PART", "");
      }
;

/* FORMAL_PARAMETER_PART */
FORMAL_PARAMETER_PART:
      '(' IDENTIFIER_LIST ')'
      {
         found("FORMAL_PARAMETER_PART", "");
      }
;

/* IDENTIFIER_LIST */
IDENTIFIER_LIST:
      IDENT
    | IDENT ',' IDENTIFIER_LIST
;

/* OPT_VIRTUAL_PART */
OPT_VIRTUAL_PART:
      %empty
      {
         found("empty VIRTUAL_PART", "");
      }
    | VIRTUAL_PART ';'
      {
         found("VIRTUAL_PART", "");
      }
;

/* VIRTUAL_PART */
VIRTUAL_PART:
      KW_VIRTUAL ':' VIRTUAL_SPEC ';'
;

/* VIRTUAL_SPEC */
VIRTUAL_SPEC:
      SPECIFIER IDENTIFIER_LIST
    | KW_PROCEDURE IDENT PROCEDURE_SPECIFICATION
;

/* PROCEDURE_SPECIFICATION */
PROCEDURE_SPECIFICATION:
      KW_IS PROCEDURE_DECLARATION
;

/* SPECIFICATION_PART */
SPECIFICATION_PART:
      SPECIFIER IDENTIFIER_LIST
      {
         found("SPECIFICATION_PART", "");
      }
    | SPECIFIER IDENTIFIER_LIST ',' SPECIFICATION_PART
      {
         found("SPECIFICATION_PART", "");
      }
;

/* SPECIFIER */
SPECIFIER:
      TYPE OPT_ARRAY_PROC
      {
         found("SPECIFIER", "");
      }
;

/* OPT_ARRAY_PROC */
OPT_ARRAY_PROC:
      %empty
    | KW_ARRAY
    | KW_PROCEDURE
;

/* TYPE */
TYPE:
      VALUE_TYPE
      {
         found("VALUE_TYPE", "");
      }
    | REFERENCE_TYPE
;

/* VALUE_TYPE */
VALUE_TYPE:
      ARITHMETIC_TYPE
    | KW_BOOLEAN
    | KW_CHARACTER
;

/* ARITHMETIC_TYPE */
ARITHMETIC_TYPE:
      INTEGER_TYPE
    | REAL_TYPE
;

/* INTEGER_TYPE */
INTEGER_TYPE:
      OPT_KW_SHORT KW_INTEGER
;

/* OPT_KW_SHORT */
OPT_KW_SHORT:
      %empty
    | KW_SHORT
;

/* REAL_TYPE */
REAL_TYPE:
      OPT_KW_SHORT KW_REAL
;

/* OPT_KW_LONG */
OPT_KW_LONG:
      %empty 
    | KW_LONG
;

/* OPT_VALUE_PART */
OPT_VALUE_PART:
      %empty
    | SPECIFICATION_PART
;

/* CLASS_BODY */
CLASS_BODY:
      BLOCK
      {
         found("CLASS_BODY", "");
      }
;

/* COMPOUND_STATEMENT */
COMPOUND_STATEMENT:
      KW_BEGIN COMPOUND_TAIL
;

/* COMPOUND_TAIL */
COMPOUND_TAIL:
      STATEMENTS KW_END
      {
         found("BLOCK", "");
      }
;

/* STATEMENTS */
STATEMENTS:
      %empty
    | STATEMENT {found("STATEMENT", "");}
    | STATEMENT ';' STATEMENTS {found("STATEMENT", "");}
;

/* STATEMENT */
STATEMENT:
      UNCONDITIONAL_STATEMENT
    | FOR_STATEMENT
;

/* UNCONDITIONAL_STATEMENT */
UNCONDITIONAL_STATEMENT:
      ASSIGNMENT_STATEMENT
    | PROCEDURE_STATEMENT_1
    | IDENTIFIER_1 
    | OBJECT_GENERATOR 
    | COMPOUND_STATEMENT 
    | BLOCK 
    | DUMMY_STATEMENT
;

/* ASSIGNMENT_STATEMENT */
ASSIGNMENT_STATEMENT:
      VALUE_ASSIGNMENT {found("ASSIGNMENT_STATEMENT", "");}
    | REFERENCE_ASSIGNMENT {found("ASSIGNMENT_STATEMENT", "");}
;

/* VALUE_ASSIGNMENT */
VALUE_ASSIGNMENT:
      VALUE_LEFT_PART ASSIGN VALUE_RIGHT_PART
;

/* VALUE_LEFT_PART */
VALUE_LEFT_PART:
      PROCEDURE_STATEMENT_1 
    | IDENTIFIER_1
;

/* VALUE_RIGHT_PART */
VALUE_RIGHT_PART:
      VALUE_EXPRESSION
    | TEXT_EXPRESSION
    | VALUE_ASSIGNMENT
    | OBJECT_EXPRESSION
;

/* DESTINATION */
DESTINATION:
      VARIABLE
;

/* SIMPLE_TEXT_EXPRESSION */
SIMPLE_TEXT_EXPRESSION:
      TEXT_PRIMARY
    | TEXT_PRIMARY '&' SIMPLE_TEXT_EXPRESSION
;

/* TEXT_PRIMARY */
TEXT_PRIMARY:
      KW_NOTEXT
    | TEXT_CONST
    | VARIABLE
    | FUNCTION_DESIGNATOR
    | '(' TEXT_EXPRESSION ')'
;

/* VARIABLE */
VARIABLE:
      IDENT
    | SUBSCRIPTED_VARIABLE
;

/* SUBSCRIPTED_VARIABLE */
SUBSCRIPTED_VARIABLE:
      IDENT '(' SUBSCRIPT_LIST ')'
;

/* SUBSCRIPT_LIST */
SUBSCRIPT_LIST:
      SUBSCRIPT_EXPRESSION
    | SUBSCRIPT_EXPRESSION ',' SUBSCRIPT_LIST
;

/* SUBSCRIPT_EXPRESSION */
SUBSCRIPT_EXPRESSION:
      ARITHMETIC_EXPRESSION
;

/* ARITHMETIC_EXPRESSION */
ARITHMETIC_EXPRESSION:
      UNSIGNED_NUMBER
    | FUNCTION_DESIGNATOR
    | ARITHMETIC_EXPRESSION '+' ARITHMETIC_EXPRESSION
    | ARITHMETIC_EXPRESSION '-' ARITHMETIC_EXPRESSION
    | ARITHMETIC_EXPRESSION '*' ARITHMETIC_EXPRESSION
    | ARITHMETIC_EXPRESSION '/' ARITHMETIC_EXPRESSION
    | ARITHMETIC_EXPRESSION INT_DIV ARITHMETIC_EXPRESSION
    | '(' ARITHMETIC_EXPRESSION ')'
;

/* UNSIGNED_NUMBER */
UNSIGNED_NUMBER:
      INTEGER_CONST
    | REAL_CONST
;

/* FUNCTION_DESIGNATOR */
FUNCTION_DESIGNATOR:
      IDENT ACTUAL_PARAMETER_PART
;

/* TEXT_EXPRESSION */
TEXT_EXPRESSION:
      SIMPLE_TEXT_EXPRESSION
;

/* VALUE_EXPRESSION */
VALUE_EXPRESSION:
      ARITHMETIC_EXPRESSION
;

/* REFERENCE_ASSIGNEMENT */
REFERENCE_ASSIGNMENT:
      REFERENCE_LEFT_PART REF_ASSIGN REFERENCE_RIGHT_PART
;

/* REFERENCE_LEFT_PART */
REFERENCE_LEFT_PART:
      DESTINATION
;

/*  REFERENCE_RIGHT_PART */
REFERENCE_RIGHT_PART:
      REFERENCE_EXPRESSION
    | REFERENCE_ASSIGNMENT
;

/* REFERENCE_EXPRESSION */
REFERENCE_EXPRESSION:
      OBJECT_EXPRESSION
   | TEXT_EXPRESSION
;

/* OBJECT_EXPRESSION */
OBJECT_EXPRESSION:
      SIMPLE_OBJECT_EXPRESSION
;

/* SIMPLE_OBJECT_EXPRESSION */
 SIMPLE_OBJECT_EXPRESSION:
      KW_NONE
    | OBJECT_GENERATOR
    | '(' OBJECT_EXPRESSION ')'
;

/* REFERENCE_TYPE */
REFERENCE_TYPE:
      OBJECT_REFERENCE_TYPE
    | KW_TEXT
;

/* OBJECT_REFERENCE_TYPE */
OBJECT_REFERENCE_TYPE:
      KW_REF '(' QUALIFICATION ')'
;

/* QUALIFICATION */
QUALIFICATION:
      IDENT
;

/* PROCEDURE_STATEMENT_1 */
PROCEDURE_STATEMENT_1:
      PROCEDURE_STATEMENT
    | REMOTE_PREFIX
;

/* REMOTE_PREFIX */
REMOTE_PREFIX:
      PREFIX
      {
         found("REMOTE_PREFIX", $1);
         strcpy($$, $1);
      }
    | PREFIX '.' REMOTE_PREFIX
      {
         found("REMOTE_PREFIX", "");
         snprintf($$, MAX_STR_LEN, "%s.%s", $1, $3);
      }
;

PREFIX:
      IDENT
      {
         strcpy($$, $1);
      }
    | PROCEDURE_STATEMENT
      {
         strcpy($$, $1);
      }
;

/* PROCEDURE_STATEMENT */
PROCEDURE_STATEMENT:
      IDENT ACTUAL_PARAMETER_PART
      {
         found("PROCEDURE_STATEMENT", $1);
         strcpy($$, $1);
      }
;

/* OPT_ACTUAL_PARAMETER_PART */
OPT_ACTUAL_PARAMETER_PART:
      %empty
    | ACTUAL_PARAMETER_PART
;

/* ACTUAL_PARAMETER_PART */
ACTUAL_PARAMETER_PART:
      '(' ACTUAL_PARAMETERS ')'
;

/* ACTUAL_PARAMETERS */
ACTUAL_PARAMETERS:
      ACTUAL_PARAMETER
    | ACTUAL_PARAMETER ',' ACTUAL_PARAMETERS
;

/* ACTUAL_PARAMETER */
ACTUAL_PARAMETER:
      EXPRESSION
;

/* EXPRESSION */
EXPRESSION:
      INTEGER_CONST
    | IDENT
    | TEXT_CONST
    | CHARACTER_CONST
;

/* IDENTIFIER_1 */
IDENTIFIER_1:
      IDENT {strcpy($$, $1);}
    | REMOTE_PREFIX '.' IDENTIFIER_1 {strcpy($$, $3);}
;

/* PROCEDURE_DECLARATION */
PROCEDURE_DECLARATION:
      OPT_TYPE KW_PROCEDURE PROCEDURE_HEADING PROCEDURE_BODY
      {
         found("PROCEDURE_DECLARATION", $3);
      }
;

/* OPT_TYPE */
OPT_TYPE:
      %empty
    | TYPE
;

/* PROCEDURE_HEADING */
PROCEDURE_HEADING:
      %empty
    | IDENT PROCEDURE_PARTS 
      {
         found("PROCEDURE_HEADING", $1);
         strcpy($$, $1);
      }
;

/* PROCEDURE_PARTS */
PROCEDURE_PARTS:
      %empty   
    | FORMAL_PARAMETER_PART OPT_MODE_PART SPECIFICATION_PART
;

/* PROCEDURE_BODY */
PROCEDURE_BODY:
      STATEMENTS
;

/* OBJECT_GENERATOR */
OBJECT_GENERATOR:
      KW_NEW IDENT OPT_ACTUAL_PARAMETER_PART
;

/* OPT_MODE_PART */
OPT_MODE_PART:
      %empty
;

/* DUMMY_STATEMENT */
DUMMY_STATEMENT:
      %empty
;

/* SIMPLE_VARIABLE_DECLARATION */
SIMPLE_VARIABLE_DECLARATION:
      TYPE TYPE_LIST
;

/* TYPE_LIST */
TYPE_LIST:
      TYPE_LIST_ELEMENT
    | TYPE_LIST_ELEMENT ',' TYPE_LIST
;

/* TYPE_LIST_ELEMENT */
TYPE_LIST_ELEMENT:
      IDENT
    | CONSTANT_ELEMENT
;

/* CONSTANT_ELEMENT */
CONSTANT_ELEMENT:
      IDENT '=' VALUE_OR_TEXT_EXPRESSION
;

/* VALUE_OR_TEXT_EXPRESSION */
VALUE_OR_TEXT_EXPRESSION:
      VALUE_EXPRESSION
    | TEXT_EXPRESSION
;

/* FOR_STATEMENT */
FOR_STATEMENT:
      KW_FOR IDENT FOR_RIGHT_PART KW_DO STATEMENT
;

/* FOR_RIGHT_PART */
FOR_RIGHT_PART:
      VALUE_FOR_LIST_ELEMENTS
    | REFERENCE_FOR_LIST_ELEMENTS
;

/* VALUE_FOR_LIST_ELEMENTS */
VALUE_FOR_LIST_ELEMENTS:
      VALUE_FOR_LIST_ELEMENT
    | VALUE_FOR_LIST_ELEMENT ',' VALUE_FOR_LIST_ELEMENTS
;

/* VALUE_FOR_LIST_ELEMENT */
VALUE_FOR_LIST_ELEMENT:
      VALUE_EXPRESSION OPT_WHILE
    | ARITHMETIC_EXPRESSION KW_STEP ARITHMETIC_EXPRESSION KW_UNTIL ARITHMETIC_EXPRESSION
;

/* REFERENCE_FOR_LIST_ELEMENTS */
REFERENCE_FOR_LIST_ELEMENTS:
      REFERENCE_FOR_LIST_ELEMENT
    | REFERENCE_FOR_LIST_ELEMENT ',' REFERENCE_FOR_LIST_ELEMENTS
;

/* REFERENCE_FOR_LIST_ELEMENT */
REFERENCE_FOR_LIST_ELEMENT:
      REFERENCE_EXPRESSION OPT_WHILE
;

/* OPT_WHILE */
OPT_WHILE:
      %empty
;

/* ARRAY_DECLARATION */
ARRAY_DECLARATION:
      OPT_TYPE
    | KW_ARRAY ARRAY_SEGMENTS
;

/* ARRAY_SEGMENTS */
ARRAY_SEGMENTS:
      ARRAY_SEGMENT
    | ARRAY_SEGMENT ',' ARRAY_SEGMENTS
;

/* ARRAY_SEGMENT */
ARRAY_SEGMENT:
      IDENTIFIER_LIST '(' BOUND_PAIR_LIST ')'
;

/* BOUND_PAIR_LIST */
BOUND_PAIR_LIST:
      BOUND_PAIR
    | BOUND_PAIR ',' BOUND_PAIR_LIST
;

/* BOUND_PAIR */
BOUND_PAIR:
      ARITHMETIC_EXPRESSION ':' ARITHMETIC_EXPRESSION
;

%%


int main( void )
{
	int ret;
	yydebug = 1;
	printf( "Author: first nad last name\n" );
	printf( "yytext              Token type      Token value as string\n\n" );
	ret = yyparse();
	return ret;
}

void yyerror(const char *txt)
{
	printf("Syntax error %s\n", txt);
}

void found(const char *nonterminal, const char *value)
{ /* info on syntax structures found */
	printf( "======== FOUND: %s %s%s%s ========\n", nonterminal, 
		(*value) ? "'" : "", value, (*value) ? "'" : "" );
}
