# P2 Class: Syntax Analyzer for a Simplified Simula Language

## 1. Objective

The goal of this exercise is to create a simple syntax analyzer for a highly simplified version of the Simula programming language.  
The analyzer’s tasks include:

- Recognizing syntactic constructions of the Simula language  
- Detecting syntax errors  

---

## 2. Preliminary files

- **Makefile** — required for compilation using the `make` command  
- **common.h** — header file containing the definition of the maximum string length  
- **simula.y** — skeleton syntax analyzer with comments and the defined `found()` function  
- **test.sim** — a test program that is syntactically correct according to the given grammar  

---

## 3. Tasks to Complete

You will need the **lexical analyzer** prepared in the previous exercise.  
If your lexical analyzer is incomplete, make sure to fill in the missing parts.

Complete the provided syntax analyzer skeleton and verify that it works correctly by testing it with the supplied test programs.  
The analyzer should print information about the recognized syntactic constructions.  

This output is generated by the `found()` function included in the provided skeleton.  
The function has two parameters:

- The name of the recognized construction (should correspond to the grammar variable name)
- An argument that is meaningful (non-empty) for certain constructions, such as function names.

You should complete the provided code with the following elements:

A. **Procedure heading** (`PROCEDURE HEADING`)  
B. **Procedure declaration** (`PROCEDURE DECLARATION`)  
C. **Class body** (`CLASS BODY`)  
D. **Class declaration** (`CLASS DECLARATION`)  
E. **Formal parameter part** (`FORMAL PARAMETER PART`)  
F. **Specification part** (`SPECIFICATION PART`)  
G. **Formal parameter, value, and specification part** (`FVS PART`)  
H. **Declaration** (`DECLARATION`)  
I. **Procedure call** (`PROCEDURE STATEMENT`)  
J. **Block** (`BLOCK`)  
K. **Reference type** (`REFERENCE TYPE`)  
L. **For loop** (`FOR STATEMENT`)  
M. **Assignment statement** (`ASSIGNMENT STATEMENT`)  
N. **Remote prefix** (`REMOTE PREFIX`)  
O. **End of program**

---

## 4. Incremental Compilation

The syntax analyzer can be developed incrementally.  
Assume that at the beginning of the grammar, you have the following rule:

```text
1 A: B C D
2 ;
```

If written like this, you must also expand all variables on the right-hand side of the rule.  
If **A** is the start symbol of the grammar, then you must define all grammar rules.

However, it’s not always possible to finish the full syntax analyzer during the class, and a non-functional analyzer results in **0 points**.  
To avoid this, rules can be written **incrementally**, step by step.  

For instance, you can temporarily comment out parts of the rule:

```text
1 A: B /* C D */
2 ;
```

Now you only need to expand **B** and the variables within its definition.  
The analyzer will compile and can be tested. Later, you can move the comment to include **C**.  

Commenting out unused parts is better than deleting them, as it shows the rule’s intended continuation.

When compiling a partially implemented syntax analyzer, you may encounter issues with the `%type` directive, which refers to variables not yet defined in any rule.  
In such cases, comment out the directive until the corresponding rules are added.

---
